

impl Capsule {
    pub fn new(r: &PublicKey, u: &PublicKey) -> Result<Capsule> {
        let capsule_internal = internal::Capsule {
            r: r._internal_key,
            u: u._internal_key,
        };
        Capsule::try_from(capsule_internal)
    }
    pub fn r(&self) -> &PublicKey {
        &self.r
    }
    pub fn u(&self) -> &PublicKey {
        &self.u
    }
}

pub struct CiphertextBlock {
    ciphertext: Vec<u8>,
    capsule: Capsule,
}

impl CiphertextBlock {
    pub fn new(ctext: &Vec<u8>, caps: internal::Capsule<Monty256>) -> Result<CiphertextBlock> {
        Ok(CiphertextBlock {
            ciphertext: ctext.to_vec(),
            capsule: Capsule::try_from(caps)?,
        })
    }
    fn try_from(ctext: Vec<u8>, caps: internal::Capsule<Monty256>) -> Result<Self> {
        Ok(CiphertextBlock {
            ciphertext: ctext,
            capsule: Capsule::try_from(caps)?,
        })
    }
}

fn encrypt_ss(
    &self,
    plaintext: &Plaintext,
    from_public_key: &PublicKey,
    signing_keypair: &SigningKeypair,
) -> Result<CiphertextBlock> {
    let group = EcGroup::from_curve_name(Nid::SECP256K1).expect("Er");
    let point = EcPoint::new(&group).expect("Er");
    let key = EcKey::generate(&group).unwrap();
    let point2 = key.public_key();

    //generate a ephemeral private key
    let r_private_key = self.random_private_key();
    let u_private_key = self.random_private_key();

    let plaintext_fp12 = plaintext._internal_fp12;

    let (ciphertext, capsule_int) = internal::encrypt_ss(
        from_public_key._internal_key,
        plaintext_fp12,
        internal::PrivateKey::from(r_private_key),
        internal::PrivateKey::from(u_private_key),
        &self.curve_points,
    )?;

    CiphertextBlock::try_from(ciphertext, capsule_int)
}

pub struct Capsule<T: Field> {
    pub r: PublicKey<T>,
    pub u: PublicKey<T>,
}


pub fn encapsulate_ss<T: Clone>(
    from_public_key: PublicKey<T>,
    r_private_key: PrivateKey<T>,
    u_private_key: PrivateKey<T>,
    curve_points: &CurvePoints<T>,
) -> (Vec<u8>, Capsule<T>)
where
    T: ExtensionField + PairingConfig + BitRepr + Hashable + ConstantSwap,
{
    let r_pub_key = PublicKey {
        value: curve_points.generator * r_private_key,
    };
    let u_pub_key = PublicKey {
        value: curve_points.generator * u_private_key,
    };
    //TODO hash s

    let kdf = Blake2b::kdf();
    let base_key = (from_public_key.value * (r_private_key.add(u_private_key))).to_bytes();
    let salt = vec![0; 16];
    let info = vec![0; 16];

    let mut buf = vec![0; 32];
    kdf.derive(&mut buf, &base_key, &salt, &info).unwrap();

    (
        buf,
        Capsule {
            r: r_pub_key,
            u: u_pub_key,
        },
    )
}

pub fn encrypt_ss<T: Clone>(
    from_public_key: PublicKey<T>,
    plaintext: Fp12Elem<T>,
    r_private_key: PrivateKey<T>,
    u_private_key: PrivateKey<T>,
    curve_points: &CurvePoints<T>,
) -> ErrorOr<(Vec<u8>, Capsule<T>)>
where
    T: ExtensionField + PairingConfig + BitRepr + Hashable + ConstantSwap,
{
    let (key, capsule) =
        encapsulate_ss(from_public_key, r_private_key, u_private_key, curve_points);

    let secret_key = aead::SecretKey::from_slice(&key).unwrap();
    let ciphertext = aead::seal(&secret_key, &plaintext.to_bytes()).expect("Sync enc error");
    //let decrypted_data = aead::open(&secret_key, &ciphertext).expect("Sync dec error");

    Ok((ciphertext, capsule))
}